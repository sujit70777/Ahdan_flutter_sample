{
    "sourceFile": "lib/algorithm.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1747677794470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747678807980,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,15 +107,12 @@\n   final hAsr = calculateHourAngle(asrAltitude);\n \n   // Step 4: Convert hour angles to times in UTC\n   DateTime timeFromHourAngle(double hRadians, bool isBeforeNoon) {\n-    final hDegrees =\n-        hRadians * 180 / 3.1415926535; // Convert radians to degrees\n-    final offsetHours =\n-        (isBeforeNoon ? -hDegrees : hDegrees) / 15; // Hours from solar noon\n-    return transitUtc.add(\n-      Duration(microseconds: (offsetHours * 60 * 60 * 1000000).round()),\n-    );\n+    final hDegrees = radiansToDegrees(hRadians);\n+    final offsetHours = isBeforeNoon ? -hDegrees / 15 : hDegrees / 15;\n+    final offsetMicroseconds = (offsetHours * 60 * 60 * 1000000).round();\n+    return transitUtc.add(Duration(microseconds: offsetMicroseconds));\n   }\n \n   final sunriseUtc = timeFromHourAngle(hSunrise, true);\n   final sunsetUtc = timeFromHourAngle(hSunset, false);\n"
                }
            ],
            "date": 1747677794470,
            "name": "Commit-0",
            "content": "import 'dart:math';\n\n/// Calculates Islamic prayer times for a given location and date using the MWL method.\n///\n/// Parameters:\n/// - [latitude]: Latitude in degrees (e.g., 60.1695 for Helsinki).\n/// - [longitude]: Longitude in degrees (e.g., 24.9354 for Helsinki).\n/// - [date]: Local date for which to calculate prayer times.\n/// - [timeZoneOffset]: Time zone offset in hours (e.g., 3 for UTC+3).\n/// - [isHanafi]: True for Hanafi Asr calculation (shadow = 2x), false for Shafi'i (1x).\n/// - [fajrAngle]: MWL Fajr angle (default: 18°).\n/// - [ishaAngle]: MWL Isha angle (default: 17°).\n///\n/// Returns a map of prayer names to their local DateTime values.\nMap<String, DateTime> calculatePrayerTimes({\n  required double latitude,\n  required double longitude,\n  required DateTime date,\n  required double timeZoneOffset,\n  bool isHanafi = true,\n  double fajrAngle = 18.0,\n  double ishaAngle = 17.0,\n}) {\n  // Helper functions\n  double degreesToRadians(double degrees) => degrees * pi / 180;\n  double radiansToDegrees(double radians) => radians * 180 / pi;\n\n  // Calculate Julian Day for UTC midnight\n  final localMidnight = DateTime(date.year, date.month, date.day, 0, 0, 0);\n  final utcMidnight = localMidnight.subtract(\n    Duration(hours: timeZoneOffset.toInt()),\n  );\n  double calculateJulianDay(int year, int month, int day) {\n    if (month <= 2) {\n      year -= 1;\n      month += 12;\n    }\n    final a = (year / 100).floor();\n    final b = (a / 4).floor();\n    final c = 2 - a + b;\n    final e = (365.25 * (year + 4716)).floor();\n    final f = (30.6001 * (month + 1)).floor();\n    return c + day + e + f - 1524.5;\n  }\n\n  final jd = calculateJulianDay(\n    utcMidnight.year,\n    utcMidnight.month,\n    utcMidnight.day,\n  );\n\n  // Step 1: Calculate solar coordinates\n  final t = jd - 2451545.0;\n  final meanAnomaly = (357.5291 + 0.98560028 * t) % 360;\n  final eclipticLongitude =\n      (meanAnomaly +\n          1.9148 * sin(degreesToRadians(meanAnomaly)) +\n          0.0200 * sin(degreesToRadians(2 * meanAnomaly)) +\n          282.634) %\n      360;\n  final obliquity = 23.439 - 0.00000036 * t;\n  final declination = radiansToDegrees(\n    asin(\n      sin(degreesToRadians(obliquity)) *\n          sin(degreesToRadians(eclipticLongitude)),\n    ),\n  );\n\n  // Step 2: Calculate equation of time and solar noon\n  final equationOfTime =\n      0.0053 * sin(degreesToRadians(meanAnomaly)) -\n      0.0069 * sin(degreesToRadians(2 * eclipticLongitude));\n  final transitUtcHours = 12 - (longitude / 15) - equationOfTime;\n  final transitUtc = utcMidnight.add(\n    Duration(\n      microseconds: ((transitUtcHours / 24) * 24 * 60 * 60 * 1000000).round(),\n    ),\n  );\n\n  // Step 3: Calculate hour angles for prayer times\n  double calculateHourAngle(double altitude) {\n    final cosH =\n        (sin(degreesToRadians(altitude)) -\n            sin(degreesToRadians(latitude)) *\n                sin(degreesToRadians(declination))) /\n        (cos(degreesToRadians(latitude)) * cos(degreesToRadians(declination)));\n    return cosH >= -1 && cosH <= 1 ? acos(cosH) : double.nan;\n  }\n\n  // Sunrise and sunset (h = 0°)\n  final hSunrise = calculateHourAngle(0);\n  final hSunset = hSunrise;\n\n  // Fajr (h = -18°)\n  final hFajr = calculateHourAngle(-fajrAngle);\n\n  // Isha (h = -17°)\n  final hIsha = calculateHourAngle(-ishaAngle);\n\n  // Asr (Hanafi: shadow = 2x, Shafi'i: 1x)\n  final shadowFactor = isHanafi ? 2.0 : 1.0;\n  final asrAltitude = radiansToDegrees(\n    atan(\n      1 / (shadowFactor + tan(degreesToRadians(latitude - declination).abs())),\n    ),\n  );\n  final hAsr = calculateHourAngle(asrAltitude);\n\n  // Step 4: Convert hour angles to times in UTC\n  DateTime timeFromHourAngle(double hRadians, bool isBeforeNoon) {\n    final hDegrees =\n        hRadians * 180 / 3.1415926535; // Convert radians to degrees\n    final offsetHours =\n        (isBeforeNoon ? -hDegrees : hDegrees) / 15; // Hours from solar noon\n    return transitUtc.add(\n      Duration(microseconds: (offsetHours * 60 * 60 * 1000000).round()),\n    );\n  }\n\n  final sunriseUtc = timeFromHourAngle(hSunrise, true);\n  final sunsetUtc = timeFromHourAngle(hSunset, false);\n  var fajrUtc = hFajr.isNaN ? null : timeFromHourAngle(hFajr, true);\n  var ishaUtc = hIsha.isNaN ? null : timeFromHourAngle(hIsha, false);\n  final asrUtc = timeFromHourAngle(hAsr, false);\n  final dhuhrUtc = transitUtc.add(Duration(minutes: 2)); // 2 min after noon\n\n  // Step 5: High latitude adjustment for Fajr and Isha\n  if (fajrUtc == null || ishaUtc == null) {\n    final nightDuration =\n        sunriseUtc\n            .add(Duration(days: 1))\n            .difference(sunsetUtc)\n            .inSeconds; // Approximate next sunrise\n    final seventhNight = nightDuration / 7;\n    fajrUtc ??= sunriseUtc.subtract(Duration(seconds: seventhNight.toInt()));\n    ishaUtc ??= sunsetUtc.add(Duration(seconds: seventhNight.toInt()));\n  }\n\n  // Step 6: Convert to local time\n  final localOffset = Duration(hours: timeZoneOffset.toInt());\n  return {\n    'Fajr': fajrUtc.add(localOffset),\n    'Dhuhr': dhuhrUtc.add(localOffset),\n    'Asr': asrUtc.add(localOffset),\n    'Maghrib': sunsetUtc.add(localOffset),\n    'Isha': ishaUtc.add(localOffset),\n  };\n}\n\n// Example usage\nvoid main() {\n  final prayerTimes = calculatePrayerTimes(\n    latitude: 60.1695,\n    longitude: 24.9354,\n    date: DateTime.utc(2025, 5, 18), // Use UTC date to align with JD\n    timeZoneOffset: 3.0,\n  );\n  prayerTimes.forEach((prayer, timeUtc) {\n    // Add offset to UTC time\n    var timeZoneOffset = 3.0; // Example offset for UTC+3\n    final totalMinutes =\n        timeUtc.hour * 60 + timeUtc.minute + (timeZoneOffset.toInt() * 60);\n    final localHour = (totalMinutes ~/ 60) % 24;\n    final localMinute = totalMinutes % 60;\n    print(\n      '$prayer: ${localHour.toString().padLeft(2, '0')}:${localMinute.toString().padLeft(2, '0')}',\n    );\n  });\n}\n"
        }
    ]
}