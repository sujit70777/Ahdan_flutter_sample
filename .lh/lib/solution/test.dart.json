{
    "sourceFile": "lib/solution/test.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748499130792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748499130792,
            "name": "Commit-0",
            "content": "// import 'dart:math' as math;\r\n\r\n// import 'package:logger/logger.dart';\r\n\r\n// // Time Names\r\n// const Map<String, String> timeNames = {\r\n//   'imsak': 'Imsak',\r\n//   'fajr': 'Fajr',\r\n//   'sunrise': 'Sunrise',\r\n//   'dhuhr': 'Dhuhr',\r\n//   'asr': 'Asr',\r\n//   'sunset': 'Sunset',\r\n//   'maghrib': 'Maghrib',\r\n//   'isha': 'Isha',\r\n//   'midnight': 'Midnight',\r\n// };\r\n\r\n// // Calculation Methods\r\n// const Map<String, Map<String, dynamic>> methods = {\r\n//   'MWL': {\r\n//     'name': 'Muslim World League',\r\n//     'params': {'fajr': 18, 'isha': 17},\r\n//   },\r\n//   'ISNA': {\r\n//     'name': 'Islamic Society of North America (ISNA)',\r\n//     'params': {'fajr': 15, 'isha': 15},\r\n//   },\r\n//   'Egypt': {\r\n//     'name': 'Egyptian General Authority of Survey',\r\n//     'params': {'fajr': 19.5, 'isha': 17.5},\r\n//   },\r\n//   'Makkah': {\r\n//     'name': 'Umm Al-Qura University, Makkah',\r\n//     'params': {'fajr': 18.5, 'isha': '90 min'},\r\n//   },\r\n//   'Karachi': {\r\n//     'name': 'University of Islamic Sciences, Karachi',\r\n//     'params': {'fajr': 18, 'isha': 18},\r\n//   },\r\n//   'Tehran': {\r\n//     'name': 'Institute of Geophysics, University of Tehran',\r\n//     'params': {'fajr': 17.7, 'isha': 14, 'maghrib': 4.5, 'midnight': 'Jafari'},\r\n//   },\r\n//   'Jafari': {\r\n//     'name': 'Shia Ithna-Ashari, Leva Institute, Qum',\r\n//     'params': {'fajr': 16, 'isha': 14, 'maghrib': 4, 'midnight': 'Jafari'},\r\n//   },\r\n// };\r\n\r\n// // Default Parameters\r\n// const Map<String, dynamic> defaultParams = {\r\n//   'maghrib': '0 min',\r\n//   'midnight': 'Standard',\r\n// };\r\n\r\n// class PrayTimes {\r\n//   // Default Settings\r\n//   String _calcMethod = 'MWL';\r\n\r\n//   Map<String, dynamic> _setting = {\r\n//     'imsak': '10 min',\r\n//     'dhuhr': '0 min',\r\n//     'asr': 'Standard',\r\n//     'highLats': 'NightMiddle',\r\n//   };\r\n\r\n//   String _timeFormat = '24h';\r\n//   List<String> _timeSuffixes = ['am', 'pm'];\r\n//   String _invalidTime = '-----';\r\n//   int _numIterations = 1;\r\n//   Map<String, double> _offset = {};\r\n\r\n//   // Local Variables\r\n//   double _lat = 0;\r\n//   double _lng = 0;\r\n//   double _elv = 0;\r\n//   double _timeZone = 0;\r\n//   double _jDate = 0;\r\n\r\n//   // Constructor\r\n//   PrayTimes([String method = 'MWL']) {\r\n//     // Set methods defaults\r\n//     for (String methodKey in methods.keys) {\r\n//       Map<String, dynamic> params = Map.from(methods[methodKey]!['params']);\r\n//       for (String defKey in defaultParams.keys) {\r\n//         if (!params.containsKey(defKey)) {\r\n//           params[defKey] = defaultParams[defKey];\r\n//         }\r\n//       }\r\n//       // Update the methods map (create a mutable copy)\r\n//     }\r\n\r\n//     // Initialize settings\r\n//     _calcMethod = methods.containsKey(method) ? method : _calcMethod;\r\n//     Map<String, dynamic> params = methods[_calcMethod]!['params'];\r\n//     for (String id in params.keys) {\r\n//       _setting[id] = params[id];\r\n//     }\r\n\r\n//     // Initialize time offsets\r\n//     for (String timeName in timeNames.keys) {\r\n//       _offset[timeName] = 0;\r\n//     }\r\n//   }\r\n\r\n//   // Set calculation method\r\n//   void setMethod(String method) {\r\n//     if (methods.containsKey(method)) {\r\n//       adjust(methods[method]!['params']);\r\n//       _calcMethod = method;\r\n//     }\r\n//   }\r\n\r\n//   // Set calculating parameters\r\n//   void adjust(Map<String, dynamic> params) {\r\n//     for (String id in params.keys) {\r\n//       _setting[id] = params[id];\r\n//     }\r\n//   }\r\n\r\n//   // Set time offsets\r\n//   void tune(Map<String, double> timeOffsets) {\r\n//     for (String i in timeOffsets.keys) {\r\n//       _offset[i] = timeOffsets[i]!;\r\n//     }\r\n//   }\r\n\r\n//   // Get current calculation method\r\n//   String getMethod() => _calcMethod;\r\n\r\n//   // Get current setting\r\n//   Map<String, dynamic> getSetting() => Map.from(_setting);\r\n\r\n//   // Get current time offsets\r\n//   Map<String, double> getOffsets() => Map.from(_offset);\r\n\r\n//   // Get default calc parameters\r\n//   Map<String, Map<String, dynamic>> getDefaults() => methods;\r\n\r\n//   // Return prayer times for a given date\r\n//   Map<String, String> getTimes(\r\n//     dynamic date,\r\n//     List<double> coords, [\r\n//     dynamic timezone,\r\n//     dynamic dst,\r\n//     String? format,\r\n//   ]) {\r\n//     _lat = coords[0];\r\n//     _lng = coords[1];\r\n//     _elv = coords.length > 2 ? coords[2] : 0;\r\n//     _timeFormat = format ?? _timeFormat;\r\n\r\n//     List<int> dateArray;\r\n//     if (date is DateTime) {\r\n//       dateArray = [date.year, date.month, date.day];\r\n//     } else if (date is List<int>) {\r\n//       dateArray = date;\r\n//     } else {\r\n//       throw ArgumentError('Date must be DateTime or List<int>');\r\n//     }\r\n\r\n//     if (timezone == null || timezone == 'auto') {\r\n//       timezone = getTimeZone(dateArray);\r\n//     }\r\n//     if (dst == null || dst == 'auto') {\r\n//       dst = getDst(dateArray);\r\n//     }\r\n\r\n//     _timeZone =\r\n//         (timezone is String ? double.parse(timezone) : timezone.toDouble()) +\r\n//         (dst == true || dst == 1 ? 1 : 0);\r\n//     _jDate =\r\n//         julian(dateArray[0], dateArray[1], dateArray[2]) - _lng / (15 * 24);\r\n\r\n//     return computeTimes();\r\n//   }\r\n\r\n//   // Convert float time to the given format\r\n//   String getFormattedTime(\r\n//     double time, [\r\n//     String? format,\r\n//     List<String>? suffixes,\r\n//   ]) {\r\n//     if (time.isNaN) return _invalidTime;\r\n//     if (format == 'Float') return time.toString();\r\n\r\n//     suffixes ??= _timeSuffixes;\r\n//     format ??= _timeFormat;\r\n//     // Logger().i('Formatting time: $time with format: $format');\r\n\r\n//     time = DMath.fixHour(time + 0.5 / 60); // add 0.5 minutes to round\r\n//     int hours = time.floor();\r\n//     int minutes = ((time - hours) * 60).floor();\r\n//     String suffix = (format == '12h') ? suffixes[hours < 12 ? 0 : 1] : '';\r\n//     String hour =\r\n//         (format == '24h')\r\n//             ? twoDigitsFormat(hours)\r\n//             : ((hours + 12 - 1) % 12 + 1).toString();\r\n//     return '$hour:${twoDigitsFormat(minutes)}${suffix.isNotEmpty ? ' $suffix' : ''}';\r\n//   }\r\n\r\n//   // Compute mid-day time\r\n//   double midDay(double time) {\r\n//     Map<String, double> sunPos = sunPosition(_jDate + time);\r\n//     double eqt = sunPos['equation']!;\r\n//     double noon = DMath.fixHour(12 - eqt);\r\n//     return noon;\r\n//   }\r\n\r\n//   // Compute the time at which sun reaches a specific angle below horizon\r\n//   double sunAngleTime(double angle, double time, [String direction = 'cw']) {\r\n//     Map<String, double> sunPos = sunPosition(_jDate + time);\r\n//     double decl = sunPos['declination']!;\r\n//     double noon = midDay(time);\r\n//     double t =\r\n//         (1 / 15) *\r\n//         DMath.arccos(\r\n//           (-DMath.sin(angle) - DMath.sin(decl) * DMath.sin(_lat)) /\r\n//               (DMath.cos(decl) * DMath.cos(_lat)),\r\n//         );\r\n//     return noon + (direction == 'ccw' ? -t : t);\r\n//   }\r\n\r\n//   // Compute asr time\r\n//   double asrTime(double factor, double time) {\r\n//     Map<String, double> sunPos = sunPosition(_jDate + time);\r\n//     double decl = sunPos['declination']!;\r\n//     double angle = -DMath.arccot(factor + DMath.tan((_lat - decl).abs()));\r\n//     return sunAngleTime(angle, time);\r\n//   }\r\n\r\n//   // Compute declination angle of sun and equation of time\r\n//   Map<String, double> sunPosition(double jd) {\r\n//     double D = jd - 2451545.0;\r\n//     double g = DMath.fixAngle(357.529 + 0.98560028 * D);\r\n//     double q = DMath.fixAngle(280.459 + 0.98564736 * D);\r\n//     double L = DMath.fixAngle(\r\n//       q + 1.915 * DMath.sin(g) + 0.020 * DMath.sin(2 * g),\r\n//     );\r\n\r\n//     double e = 23.439 - 0.00000036 * D;\r\n//     double RA = DMath.arctan2(DMath.cos(e) * DMath.sin(L), DMath.cos(L)) / 15;\r\n//     double eqt = q / 15 - DMath.fixHour(RA);\r\n//     double decl = DMath.arcsin(DMath.sin(e) * DMath.sin(L));\r\n\r\n//     return {'declination': decl, 'equation': eqt};\r\n//   }\r\n\r\n//   // Convert Gregorian date to Julian day\r\n//   double julian(int year, int month, int day) {\r\n//     if (month <= 2) {\r\n//       year -= 1;\r\n//       month += 12;\r\n//     }\r\n//     int A = (year / 100).floor();\r\n//     int B = 2 - A + (A / 4).floor();\r\n\r\n//     double JD =\r\n//         (365.25 * (year + 4716)).floor().toDouble() +\r\n//         (30.6001 * (month + 1)).floor().toDouble() +\r\n//         day +\r\n//         B -\r\n//         1524.5;\r\n//     return JD;\r\n//   }\r\n\r\n//   // Compute prayer times at given julian date\r\n//   Map<String, double> computePrayerTimes(Map<String, double> times) {\r\n//     times = dayPortion(times);\r\n//     Map<String, dynamic> params = _setting;\r\n\r\n//     double imsak = sunAngleTime(\r\n//       evalParam(params['imsak']),\r\n//       times['imsak']!,\r\n//       'ccw',\r\n//     );\r\n//     double fajr = sunAngleTime(\r\n//       evalParam(params['fajr']),\r\n//       times['fajr']!,\r\n//       'ccw',\r\n//     );\r\n//     double sunrise = sunAngleTime(riseSetAngle(), times['sunrise']!, 'ccw');\r\n//     double dhuhr = midDay(times['dhuhr']!);\r\n//     double asr = asrTime(asrFactor(params['asr']), times['asr']!);\r\n//     double sunset = sunAngleTime(riseSetAngle(), times['sunset']!);\r\n//     double maghrib = sunAngleTime(\r\n//       evalParam(params['maghrib']),\r\n//       times['maghrib']!,\r\n//     );\r\n//     double isha = sunAngleTime(evalParam(params['isha']), times['isha']!);\r\n\r\n//     return {\r\n//       'imsak': imsak,\r\n//       'fajr': fajr,\r\n//       'sunrise': sunrise,\r\n//       'dhuhr': dhuhr,\r\n//       'asr': asr,\r\n//       'sunset': sunset,\r\n//       'maghrib': maghrib,\r\n//       'isha': isha,\r\n//     };\r\n//   }\r\n\r\n//   // Compute prayer times\r\n//   Map<String, String> computeTimes() {\r\n//     // Default times\r\n//     Map<String, double> times = {\r\n//       'imsak': 5,\r\n//       'fajr': 5,\r\n//       'sunrise': 6,\r\n//       'dhuhr': 12,\r\n//       'asr': 13,\r\n//       'sunset': 18,\r\n//       'maghrib': 18,\r\n//       'isha': 18,\r\n//     };\r\n\r\n//     // Main iterations\r\n//     for (int i = 1; i <= _numIterations; i++) {\r\n//       times = computePrayerTimes(times);\r\n//     }\r\n\r\n//     times = adjustTimes(times);\r\n\r\n//     // Add midnight time\r\n//     times['midnight'] =\r\n//         (_setting['midnight'] == 'Jafari')\r\n//             ? times['sunset']! + timeDiff(times['sunset']!, times['fajr']!) / 2\r\n//             : times['sunset']! +\r\n//                 timeDiff(times['sunset']!, times['sunrise']!) / 2;\r\n\r\n//     times = tuneTimes(times);\r\n//     return modifyFormats(times);\r\n//   }\r\n\r\n//   // Adjust times\r\n//   Map<String, double> adjustTimes(Map<String, double> times) {\r\n//     Map<String, dynamic> params = _setting;\r\n\r\n//     for (String i in times.keys) {\r\n//       times[i] = times[i]! + _timeZone - _lng / 15;\r\n//     }\r\n\r\n//     if (params['highLats'] != 'None') {\r\n//       times = adjustHighLats(times);\r\n//     }\r\n\r\n//     if (isMin(params['imsak'])) {\r\n//       times['imsak'] = times['fajr']! - evalParam(params['imsak']) / 60;\r\n//     }\r\n//     if (isMin(params['maghrib'])) {\r\n//       times['maghrib'] = times['sunset']! + evalParam(params['maghrib']) / 60;\r\n//     }\r\n//     if (isMin(params['isha'])) {\r\n//       times['isha'] = times['maghrib']! + evalParam(params['isha']) / 60;\r\n//     }\r\n//     times['dhuhr'] = times['dhuhr']! + evalParam(params['dhuhr']) / 60;\r\n\r\n//     return times;\r\n//   }\r\n\r\n//   // Get asr shadow factor\r\n//   double asrFactor(dynamic asrParam) {\r\n//     Map<String, int> factors = {'Standard': 1, 'Hanafi': 2};\r\n//     return factors[asrParam]?.toDouble() ?? evalParam(asrParam);\r\n//   }\r\n\r\n//   // Return sun angle for sunset/sunrise\r\n//   double riseSetAngle() {\r\n//     double angle = 0.0347 * math.sqrt(_elv); // approximation\r\n//     return 0.833 + angle;\r\n//   }\r\n\r\n//   // Apply offsets to the times\r\n//   Map<String, double> tuneTimes(Map<String, double> times) {\r\n//     for (String i in times.keys) {\r\n//       times[i] = times[i]! + (_offset[i] ?? 0) / 60;\r\n//     }\r\n//     return times;\r\n//   }\r\n\r\n//   // Convert times to given time format\r\n//   Map<String, String> modifyFormats(Map<String, double> times) {\r\n//     Map<String, String> result = {};\r\n//     for (String i in times.keys) {\r\n//       // Logger(level: Level.trace).f('Formatting time for $i: ${times[i]}');\r\n//       result[i] = getFormattedTime(times[i]!, _timeFormat);\r\n//     }\r\n//     return result;\r\n//   }\r\n\r\n//   // Adjust times for locations in higher latitudes\r\n//   Map<String, double> adjustHighLats(Map<String, double> times) {\r\n//     Map<String, dynamic> params = _setting;\r\n//     double nightTime = timeDiff(times['sunset']!, times['sunrise']!);\r\n\r\n//     times['imsak'] = adjustHLTime(\r\n//       times['imsak']!,\r\n//       times['sunrise']!,\r\n//       evalParam(params['imsak']),\r\n//       nightTime,\r\n//       'ccw',\r\n//     );\r\n//     times['fajr'] = adjustHLTime(\r\n//       times['fajr']!,\r\n//       times['sunrise']!,\r\n//       evalParam(params['fajr']),\r\n//       nightTime,\r\n//       'ccw',\r\n//     );\r\n//     times['isha'] = adjustHLTime(\r\n//       times['isha']!,\r\n//       times['sunset']!,\r\n//       evalParam(params['isha']),\r\n//       nightTime,\r\n//     );\r\n//     times['maghrib'] = adjustHLTime(\r\n//       times['maghrib']!,\r\n//       times['sunset']!,\r\n//       evalParam(params['maghrib']),\r\n//       nightTime,\r\n//     );\r\n\r\n//     return times;\r\n//   }\r\n\r\n//   // Adjust a time for higher latitudes\r\n//   double adjustHLTime(\r\n//     double time,\r\n//     double base,\r\n//     double angle,\r\n//     double night, [\r\n//     String direction = 'cw',\r\n//   ]) {\r\n//     double portion = nightPortion(angle, night);\r\n//     double timeDiff =\r\n//         (direction == 'ccw')\r\n//             ? this.timeDiff(time, base)\r\n//             : this.timeDiff(base, time);\r\n//     if (time.isNaN || timeDiff > portion) {\r\n//       time = base + (direction == 'ccw' ? -portion : portion);\r\n//     }\r\n//     return time;\r\n//   }\r\n\r\n//   // The night portion used for adjusting times in higher latitudes\r\n//   double nightPortion(double angle, double night) {\r\n//     String method = _setting['highLats'];\r\n//     double portion = 1 / 2; // MidNight\r\n//     if (method == 'AngleBased') {\r\n//       portion = 1 / 60 * angle;\r\n//     }\r\n//     if (method == 'OneSeventh') {\r\n//       portion = 1 / 7;\r\n//     }\r\n//     return portion * night;\r\n//   }\r\n\r\n//   // Convert hours to day portions\r\n//   Map<String, double> dayPortion(Map<String, double> times) {\r\n//     for (String i in times.keys) {\r\n//       times[i] = times[i]! / 24;\r\n//     }\r\n//     return times;\r\n//   }\r\n\r\n//   // Get local time zone\r\n//   double getTimeZone(List<int> date) {\r\n//     int year = date[0];\r\n//     double t1 = gmtOffset([year, 1, 1]);\r\n//     double t2 = gmtOffset([year, 7, 1]);\r\n//     return math.min(t1, t2);\r\n//   }\r\n\r\n//   // Get daylight saving for a given date\r\n//   bool getDst(List<int> date) {\r\n//     return gmtOffset(date) != getTimeZone(date);\r\n//   }\r\n\r\n//   // GMT offset for a given date\r\n//   double gmtOffset(List<int> date) {\r\n//     DateTime localDate = DateTime(date[0], date[1], date[2], 12, 0, 0);\r\n//     DateTime utcDate = localDate.toUtc();\r\n//     double hoursDiff =\r\n//         (localDate.millisecondsSinceEpoch - utcDate.millisecondsSinceEpoch) /\r\n//         (1000 * 60 * 60);\r\n//     return hoursDiff;\r\n//   }\r\n\r\n//   // Convert given string into a number\r\n//   double evalParam(dynamic str) {\r\n//     if (str is num) return str.toDouble();\r\n//     String strValue = str.toString();\r\n//     RegExp regex = RegExp(r'[0-9.+-]+');\r\n//     Match? match = regex.firstMatch(strValue);\r\n//     return match != null ? double.parse(match.group(0)!) : 0.0;\r\n//   }\r\n\r\n//   // Detect if input contains 'min'\r\n//   bool isMin(dynamic arg) {\r\n//     return arg.toString().contains('min');\r\n//   }\r\n\r\n//   // Compute the difference between two times\r\n//   double timeDiff(double time1, double time2) {\r\n//     return DMath.fixHour(time2 - time1);\r\n//   }\r\n\r\n//   // Add a leading 0 if necessary\r\n//   String twoDigitsFormat(int num) {\r\n//     return num < 10 ? '0$num' : num.toString();\r\n//   }\r\n// }\r\n\r\n// // Degree-Based Math Class\r\n// class DMath {\r\n//   static double dtr(double d) => (d * math.pi) / 180.0;\r\n//   static double rtd(double r) => (r * 180.0) / math.pi;\r\n\r\n//   static double sin(double d) => math.sin(dtr(d));\r\n//   static double cos(double d) => math.cos(dtr(d));\r\n//   static double tan(double d) => math.tan(dtr(d));\r\n\r\n//   static double arcsin(double d) => rtd(math.asin(d));\r\n//   static double arccos(double d) => rtd(math.acos(d));\r\n//   static double arctan(double d) => rtd(math.atan(d));\r\n\r\n//   static double arccot(double x) => rtd(math.atan(1 / x));\r\n//   static double arctan2(double y, double x) => rtd(math.atan2(y, x));\r\n\r\n//   static double fixAngle(double a) => fix(a, 360);\r\n//   static double fixHour(double a) {\r\n//     if (a == 25.305312850695834) {\r\n//       Logger(level: Level.trace).d('Fixing $a ');\r\n//     }\r\n//     return fix(a, 24);\r\n//   }\r\n\r\n//   static double fix(double a, double b) {\r\n//     if (b == 24 && a == 25.305312850695834) {\r\n//       // Logger(level: Level.trace).d('Fixing $a with modulus $b');\r\n//     }\r\n\r\n//     if (a.isNaN || a.isInfinite || b.isNaN || b.isInfinite || b == 0) {\r\n//       return double.nan;\r\n//     }\r\n//     a = a - b * (a / b).floor();\r\n//     return (a < 0) ? a + b : a;\r\n//   }\r\n// }\r\n\r\n// // // Usage Example:\r\n// // void main() {\r\n// //   PrayTimes pt = PrayTimes('ISNA');\r\n// //   Map<String, String> times = pt.getTimes(DateTime.now(), [\r\n// //     60.1699,\r\n// //     24.9384,\r\n// //   ], 3);\r\n// //   print('Sunrise: ${times['sunrise']}');\r\n// //   print('Fajr: ${times['fajr']}');\r\n// //   print('Dhuhr: ${times['dhuhr']}');\r\n// //   print('Asr: ${times['asr']}');\r\n// //   print('Maghrib: ${times['maghrib']}');\r\n// //   print('Isha: ${times['isha']}');\r\n// // }\r\n"
        }
    ]
}