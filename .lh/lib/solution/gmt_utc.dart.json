{
    "sourceFile": "lib/solution/gmt_utc.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1748459322387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1748459322387,
            "name": "Commit-0",
            "content": "import 'dart:math' as math;\n\nclass LocationTimeCalculator {\n  // Time zone data for major cities (offset in hours from UTC)\n  static const Map<String, double> _timeZoneOffsets = {\n    // Major time zones with their UTC offsets\n    'UTC-12': -12.0, 'UTC-11': -11.0, 'UTC-10': -10.0, 'UTC-9': -9.0,\n    'UTC-8': -8.0, 'UTC-7': -7.0, 'UTC-6': -6.0, 'UTC-5': -5.0,\n    'UTC-4': -4.0, 'UTC-3': -3.0, 'UTC-2': -2.0, 'UTC-1': -1.0,\n    'UTC+0': 0.0, 'UTC+1': 1.0, 'UTC+2': 2.0, 'UTC+3': 3.0,\n    'UTC+4': 4.0, 'UTC+5': 5.0, 'UTC+6': 6.0, 'UTC+7': 7.0,\n    'UTC+8': 8.0, 'UTC+9': 9.0, 'UTC+10': 10.0, 'UTC+11': 11.0, 'UTC+12': 12.0,\n  };\n\n  // Approximate time zone boundaries (longitude ranges)\n  static const List<Map<String, dynamic>> _timeZoneBoundaries = [\n    {'min': -180.0, 'max': -165.0, 'offset': -12.0}, // UTC-12\n    {'min': -165.0, 'max': -150.0, 'offset': -11.0}, // UTC-11\n    {'min': -150.0, 'max': -135.0, 'offset': -10.0}, // UTC-10\n    {'min': -135.0, 'max': -120.0, 'offset': -9.0},  // UTC-9\n    {'min': -120.0, 'max': -105.0, 'offset': -8.0},  // UTC-8\n    {'min': -105.0, 'max': -90.0, 'offset': -7.0},   // UTC-7\n    {'min': -90.0, 'max': -75.0, 'offset': -6.0},    // UTC-6\n    {'min': -75.0, 'max': -60.0, 'offset': -5.0},    // UTC-5\n    {'min': -60.0, 'max': -45.0, 'offset': -4.0},    // UTC-4\n    {'min': -45.0, 'max': -30.0, 'offset': -3.0},    // UTC-3\n    {'min': -30.0, 'max': -15.0, 'offset': -2.0},    // UTC-2\n    {'min': -15.0, 'max': 0.0, 'offset': -1.0},      // UTC-1\n    {'min': 0.0, 'max': 15.0, 'offset': 0.0},        // UTC+0\n    {'min': 15.0, 'max': 30.0, 'offset': 1.0},       // UTC+1\n    {'min': 30.0, 'max': 45.0, 'offset': 2.0},       // UTC+2\n    {'min': 45.0, 'max': 60.0, 'offset': 3.0},       // UTC+3\n    {'min': 60.0, 'max': 75.0, 'offset': 4.0},       // UTC+4\n    {'min': 75.0, 'max': 90.0, 'offset': 5.0},       // UTC+5\n    {'min': 90.0, 'max': 105.0, 'offset': 6.0},      // UTC+6\n    {'min': 105.0, 'max': 120.0, 'offset': 7.0},     // UTC+7\n    {'min': 120.0, 'max': 135.0, 'offset': 8.0},     // UTC+8\n    {'min': 135.0, 'max': 150.0, 'offset': 9.0},     // UTC+9\n    {'min': 150.0, 'max': 165.0, 'offset': 10.0},    // UTC+10\n    {'min': 165.0, 'max': 180.0, 'offset': 11.0},    // UTC+11\n  ];\n\n  /// Calculate UTC offset based on longitude (rough approximation)\n  static double _calculateUtcOffsetFromLongitude(double longitude) {\n    // Ensure longitude is in valid range\n    longitude = longitude % 360;\n    if (longitude > 180) longitude -= 360;\n    if (longitude < -180) longitude += 360;\n\n    // Find the appropriate time zone\n    for (var zone in _timeZoneBoundaries) {\n      if (longitude >= zone['min'] && longitude < zone['max']) {\n        return zone['offset'];\n      }\n    }\n    \n    // Fallback: calculate based on 15-degree zones\n    return (longitude / 15).round().toDouble();\n  }\n\n  /// Check if a year is a leap year\n  static bool _isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n  }\n\n  /// Calculate day of year\n  static int _dayOfYear(DateTime date) {\n    int dayOfYear = date.day;\n    List<int> daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    \n    if (_isLeapYear(date.year)) {\n      daysInMonth[1] = 29;\n    }\n    \n    for (int i = 0; i < date.month - 1; i++) {\n      dayOfYear += daysInMonth[i];\n    }\n    \n    return dayOfYear;\n  }\n\n  /// Calculate solar time offset (equation of time approximation)\n  static double _equationOfTime(int dayOfYear) {\n    double b = 2 * math.pi * (dayOfYear - 81) / 365;\n    return 9.87 * math.sin(2 * b) - 7.53 * math.cos(b) - 1.5 * math.sin(b);\n  }\n\n  /// Calculate solar noon for a given location and date\n  static DateTime _calculateSolarNoon(double longitude, DateTime date) {\n    int dayOfYear = _dayOfYear(date);\n    double eot = _equationOfTime(dayOfYear);\n    \n    // Solar noon occurs when the sun is directly overhead\n    // Longitude correction: 4 minutes per degree\n    double longitudeCorrection = longitude * 4; // minutes\n    double totalCorrection = eot + longitudeCorrection;\n    \n    // Solar noon in UTC is approximately 12:00 + corrections\n    DateTime utcSolarNoon = DateTime.utc(\n      date.year, \n      date.month, \n      date.day, \n      12, \n      totalCorrection.round()\n    );\n    \n    return utcSolarNoon;\n  }\n}\n\nclass TimeResult {\n  final DateTime localTime;\n  final DateTime utcTime;\n  final DateTime gmtTime;\n  final double utcOffset;\n  final String timeZone;\n  final DateTime solarNoon;\n  final Map<String, dynamic> additionalInfo;\n\n  TimeResult({\n    required this.localTime,\n    required this.utcTime,\n    required this.gmtTime,\n    required this.utcOffset,\n    required this.timeZone,\n    required this.solarNoon,\n    required this.additionalInfo,\n  });\n\n  @override\n  String toString() {\n    return '''\nTime Calculation Results:\n------------------------\nLocal Time: ${localTime.toString()}\nUTC Time: ${utcTime.toString()}\nGMT Time: ${gmtTime.toString()}\nUTC Offset: ${utcOffset >= 0 ? '+' : ''}${utcOffset.toStringAsFixed(1)} hours\nTime Zone: $timeZone\nSolar Noon (UTC): ${solarNoon.toString()}\n\nAdditional Information:\n- Day of Year: ${additionalInfo['dayOfYear']}\n- Is Leap Year: ${additionalInfo['isLeapYear']}\n- Equation of Time: ${additionalInfo['equationOfTime'].toStringAsFixed(2)} minutes\n''';\n  }\n}\n\n/// Main function to calculate GMT and UTC values from coordinates and date\nTimeResult calculateTimeFromLocation(double latitude, double longitude, DateTime inputDate) {\n  // Validate inputs\n  if (latitude < -90 || latitude > 90) {\n    throw ArgumentError('Latitude must be between -90 and 90 degrees');\n  }\n  if (longitude < -180 || longitude > 180) {\n    throw ArgumentError('Longitude must be between -180 and 180 degrees');\n  }\n\n  // Calculate UTC offset based on longitude\n  double utcOffset = LocationTimeCalculator._calculateUtcOffsetFromLongitude(longitude);\n  \n  // Determine time zone string\n  String timeZone = 'UTC${utcOffset >= 0 ? '+' : ''}${utcOffset.toInt()}';\n  \n  // Convert input date to UTC if it's not already\n  DateTime utcDate = inputDate.isUtc ? inputDate : inputDate.toUtc();\n  \n  // GMT is the same as UTC (GMT = UTC)\n  DateTime gmtDate = utcDate;\n  \n  // Calculate local time\n  Duration offsetDuration = Duration(hours: utcOffset.toInt(), minutes: ((utcOffset % 1) * 60).round());\n  DateTime localDate = utcDate.add(offsetDuration);\n  \n  // Calculate solar noon\n  DateTime solarNoon = LocationTimeCalculator._calculateSolarNoon(longitude, utcDate);\n  \n  // Calculate additional information\n  int dayOfYear = LocationTimeCalculator._dayOfYear(utcDate);\n  bool isLeapYear = LocationTimeCalculator._isLeapYear(utcDate.year);\n  double equationOfTime = LocationTimeCalculator._equationOfTime(dayOfYear);\n  \n  Map<String, dynamic> additionalInfo = {\n    'dayOfYear': dayOfYear,\n    'isLeapYear': isLeapYear,\n    'equationOfTime': equationOfTime,\n    'latitude': latitude,\n    'longitude': longitude,\n  };\n\n  return TimeResult(\n    localTime: localDate,\n    utcTime: utcDate,\n    gmtTime: gmtDate,\n    utcOffset: utcOffset,\n    timeZone: timeZone,\n    solarNoon: solarNoon,\n    additionalInfo: additionalInfo,\n  );\n}\n\n// Example usage and testing function\nvoid main() {\n  print('=== GMT/UTC Calculator Demo ===\\n');\n  \n  // Example 1: New York City\n  print('Example 1: New York City');\n  double lat1 = 40.7128;\n  double lng1 = -74.0060;\n  DateTime date1 = DateTime.now();\n  \n  try {\n    TimeResult result1 = calculateTimeFromLocation(lat1, lng1, date1);\n    print(result1);\n  } catch (e) {\n    print('Error: $e');\n  }\n  \n  print('\\n' + '='*50 + '\\n');\n  \n  // Example 2: Tokyo, Japan\n  print('Example 2: Tokyo, Japan');\n  double lat2 = 35.6762;\n  double lng2 = 139.6503;\n  DateTime date2 = DateTime(2024, 6, 15, 14, 30);\n  \n  try {\n    TimeResult result2 = calculateTimeFromLocation(lat2, lng2, date2);\n    print(result2);\n  } catch (e) {\n    print('Error: $e');\n  }\n  \n  print('\\n' + '='*50 + '\\n');\n  \n  // Example 3: London, UK\n  print('Example 3: London, UK');\n  double lat3 = 51.5074;\n  double lng3 = -0.1278;\n  DateTime date3 = DateTime.utc(2024, 12, 25, 12, 0);\n  \n  try {\n    TimeResult result3 = calculateTimeFromLocation(lat3, lng3, date3);\n    print(result3);\n  } catch (e) {\n    print('Error: $e');\n  }\n}"
        }
    ]
}