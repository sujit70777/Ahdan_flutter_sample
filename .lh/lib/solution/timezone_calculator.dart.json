{
    "sourceFile": "lib/solution/timezone_calculator.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1748444376265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748446613276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -261,14 +261,14 @@\n \n   print('=== Offline Timezone Calculator Results ===\\n');\n \n   for (var location in testLocations) {\n-    String name = location['name'];\n+    // String name = location['name'];\n     double lat = location['lat'];\n     double lon = location['lon'];\n \n     print(\n-      'Location: $name (${lat.toStringAsFixed(4)}, ${lon.toStringAsFixed(4)})',\n+      'Location: (${lat.toStringAsFixed(4)}, ${lon.toStringAsFixed(4)})',\n     );\n \n     // Method 1: Simple longitude-based\n     double simpleOffset = OfflineTimezoneCalculator.getTimezoneByLongitude(lon);\n"
                },
                {
                    "date": 1748446629854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -261,13 +261,15 @@\n \n   print('=== Offline Timezone Calculator Results ===\\n');\n \n   for (var location in testLocations) {\n-    // String name = location['name'];\n+    String name = location['name'];\n     double lat = location['lat'];\n     double lon = location['lon'];\n \n-    print('Location: (${lat.toStringAsFixed(4)}, ${lon.toStringAsFixed(4)})');\n+    print(\n+      'Location: $name (${lat.toStringAsFixed(4)}, ${lon.toStringAsFixed(4)})',\n+    );\n \n     // Method 1: Simple longitude-based\n     double simpleOffset = OfflineTimezoneCalculator.getTimezoneByLongitude(lon);\n     print(\n"
                }
            ],
            "date": 1748444376265,
            "name": "Commit-0",
            "content": "import 'dart:math' as math;\n\nclass OfflineTimezoneCalculator {\n  \n  // Method 1: Simple Longitude-based approximation (Most basic)\n  static double getTimezoneByLongitude(double longitude) {\n    // Each 15 degrees of longitude represents 1 hour of time difference\n    // Positive longitude = East (ahead of UTC), Negative = West (behind UTC)\n    return longitude / 15.0;\n  }\n\n  // Method 2: Country-based timezone mapping (More accurate)\n  static String getTimezoneByCountryBounds(double lat, double lon) {\n    // Major country/region bounds with their standard timezones\n    // This is a simplified version - you can expand with more countries\n    \n    // United States (Continental)\n    if (lat >= 24.0 && lat <= 49.0 && lon >= -125.0 && lon <= -66.0) {\n      if (lon >= -75.0) return 'America/New_York'; // Eastern: UTC-5\n      if (lon >= -90.0) return 'America/Chicago'; // Central: UTC-6\n      if (lon >= -115.0) return 'America/Denver'; // Mountain: UTC-7\n      return 'America/Los_Angeles'; // Pacific: UTC-8\n    }\n    \n    // Canada\n    if (lat >= 41.0 && lat <= 83.0 && lon >= -141.0 && lon <= -52.0) {\n      if (lon >= -60.0) return 'America/Halifax'; // Atlantic: UTC-4\n      if (lon >= -70.0) return 'America/Toronto'; // Eastern: UTC-5\n      if (lon >= -95.0) return 'America/Winnipeg'; // Central: UTC-6\n      if (lon >= -115.0) return 'America/Edmonton'; // Mountain: UTC-7\n      return 'America/Vancouver'; // Pacific: UTC-8\n    }\n    \n    // Europe\n    if (lat >= 35.0 && lat <= 71.0 && lon >= -10.0 && lon <= 40.0) {\n      if (lon >= 20.0) return 'Europe/Helsinki'; // UTC+2\n      return 'Europe/Berlin'; // UTC+1\n    }\n    \n    // Russia (simplified)\n    if (lat >= 41.0 && lat <= 82.0 && lon >= 20.0 && lon <= 180.0) {\n      if (lon >= 160.0) return 'Asia/Kamchatka'; // UTC+12\n      if (lon >= 140.0) return 'Asia/Vladivostok'; // UTC+10\n      if (lon >= 120.0) return 'Asia/Irkutsk'; // UTC+8\n      if (lon >= 100.0) return 'Asia/Krasnoyarsk'; // UTC+7\n      if (lon >= 80.0) return 'Asia/Novosibirsk'; // UTC+7\n      if (lon >= 60.0) return 'Asia/Yekaterinburg'; // UTC+5\n      return 'Europe/Moscow'; // UTC+3\n    }\n    \n    // China\n    if (lat >= 18.0 && lat <= 54.0 && lon >= 73.0 && lon <= 135.0) {\n      return 'Asia/Shanghai'; // UTC+8 (China uses single timezone)\n    }\n    \n    // India\n    if (lat >= 6.0 && lat <= 37.0 && lon >= 68.0 && lon <= 97.0) {\n      return 'Asia/Kolkata'; // UTC+5:30\n    }\n    \n    // Australia (simplified)\n    if (lat >= -44.0 && lat <= -10.0 && lon >= 113.0 && lon <= 154.0) {\n      if (lon >= 141.0) return 'Australia/Sydney'; // UTC+10\n      if (lon >= 129.0) return 'Australia/Adelaide'; // UTC+9:30\n      return 'Australia/Perth'; // UTC+8\n    }\n    \n    // Japan\n    if (lat >= 24.0 && lat <= 46.0 && lon >= 123.0 && lon <= 146.0) {\n      return 'Asia/Tokyo'; // UTC+9\n    }\n    \n    // Brazil (simplified)\n    if (lat >= -34.0 && lat <= 5.0 && lon >= -74.0 && lon <= -32.0) {\n      if (lon >= -38.0) return 'America/Sao_Paulo'; // UTC-3\n      return 'America/Manaus'; // UTC-4\n    }\n    \n    // Default: fallback to longitude-based calculation\n    double offset = getTimezoneByLongitude(lon);\n    return 'UTC${offset >= 0 ? '+' : ''}${offset.toStringAsFixed(1)}';\n  }\n\n  // Method 3: Timezone offset calculator with DST consideration\n  static Map<String, dynamic> getDetailedTimezone(double lat, double lon, {DateTime? date}) {\n    date ??= DateTime.now();\n    \n    String timezone = getTimezoneByCountryBounds(lat, lon);\n    double baseOffset = _getTimezoneOffset(timezone);\n    bool isDST = _isDaylightSavingTime(lat, lon, date);\n    double actualOffset = baseOffset + (isDST ? 1 : 0);\n    \n    return {\n      'timezone': timezone,\n      'baseOffset': baseOffset,\n      'isDST': isDST,\n      'actualOffset': actualOffset,\n      'offsetString': _formatOffset(actualOffset)\n    };\n  }\n\n  // Method 4: Grid-based timezone lookup (More precise)\n  static String getTimezoneByGrid(double lat, double lon) {\n    // Divide world into grid cells and assign timezone\n    // This is a simplified version - real implementation would use more detailed grid\n    \n    int latGrid = ((lat + 90) / 10).floor(); // 0-17 (18 rows)\n    int lonGrid = ((lon + 180) / 15).floor(); // 0-23 (24 columns)\n    \n    // Grid-based timezone mapping (simplified)\n    Map<String, String> gridTimezones = {\n      '8_0': 'Pacific/Honolulu',    // Hawaii\n      '8_1': 'America/Anchorage',   // Alaska\n      '9_4': 'America/Los_Angeles', // US West Coast\n      '9_5': 'America/Denver',      // US Mountain\n      '9_6': 'America/Chicago',     // US Central\n      '9_7': 'America/New_York',    // US East Coast\n      '10_12': 'Europe/London',     // UK\n      '10_13': 'Europe/Berlin',     // Central Europe\n      '10_14': 'Europe/Moscow',     // Russia West\n      '9_16': 'Asia/Shanghai',      // China\n      '9_17': 'Asia/Tokyo',         // Japan\n      '5_17': 'Australia/Sydney',   // Australia East\n    };\n    \n    String key = '${latGrid}_$lonGrid';\n    return gridTimezones[key] ?? 'UTC${_formatOffset(getTimezoneByLongitude(lon))}';\n  }\n\n  // Helper method: Get base timezone offset\n  static double _getTimezoneOffset(String timezone) {\n    Map<String, double> offsets = {\n      'Pacific/Honolulu': -10,\n      'America/Anchorage': -9,\n      'America/Los_Angeles': -8,\n      'America/Denver': -7,\n      'America/Chicago': -6,\n      'America/New_York': -5,\n      'America/Halifax': -4,\n      'America/Sao_Paulo': -3,\n      'America/Manaus': -4,\n      'America/Toronto': -5,\n      'America/Winnipeg': -6,\n      'America/Edmonton': -7,\n      'America/Vancouver': -8,\n      'Europe/London': 0,\n      'Europe/Berlin': 1,\n      'Europe/Helsinki': 2,\n      'Europe/Moscow': 3,\n      'Asia/Yekaterinburg': 5,\n      'Asia/Novosibirsk': 7,\n      'Asia/Krasnoyarsk': 7,\n      'Asia/Irkutsk': 8,\n      'Asia/Vladivostok': 10,\n      'Asia/Kamchatka': 12,\n      'Asia/Kolkata': 5.5,\n      'Asia/Shanghai': 8,\n      'Asia/Tokyo': 9,\n      'Australia/Perth': 8,\n      'Australia/Adelaide': 9.5,\n      'Australia/Sydney': 10,\n    };\n    \n    return offsets[timezone] ?? 0;\n  }\n\n  // Helper method: Check if DST is active\n  static bool _isDaylightSavingTime(double lat, double lon, DateTime date) {\n    // Simplified DST calculation\n    // Northern Hemisphere: DST typically March-November\n    // Southern Hemisphere: DST typically October-March\n    \n    bool isNorthern = lat > 0;\n    int month = date.month;\n    \n    if (isNorthern) {\n      // Northern hemisphere DST (US/Europe style)\n      return month >= 3 && month <= 10;\n    } else {\n      // Southern hemisphere DST (Australia style)\n      return month >= 10 || month <= 3;\n    }\n  }\n\n  // Helper method: Format offset as string\n  static String _formatOffset(double offset) {\n    if (offset == 0) return 'UTC';\n    \n    int hours = offset.floor();\n    int minutes = ((offset - hours) * 60).abs().round();\n    \n    String sign = offset >= 0 ? '+' : '-';\n    String hoursStr = hours.abs().toString().padLeft(2, '0');\n    String minutesStr = minutes.toString().padLeft(2, '0');\n    \n    return 'UTC$sign$hoursStr:$minutesStr';\n  }\n\n  // Method 5: Calculate solar timezone (based on sun position)\n  static double getSolarTimezone(double lon) {\n    // Solar timezone is purely based on longitude\n    // More accurate for solar-based calculations\n    return lon / 15.0;\n  }\n\n  // Method 6: Nautical timezone calculation\n  static String getNauticalTimezone(double lat, double lon) {\n    // Nautical timezones are based on 15-degree longitude bands\n    double rawOffset = lon / 15.0;\n    int roundedOffset = rawOffset.round();\n    \n    // Special cases for nautical timezones\n    Map<int, String> nauticalCodes = {\n      -12: 'Y', -11: 'X', -10: 'W', -9: 'V', -8: 'U', -7: 'T',\n      -6: 'S', -5: 'R', -4: 'Q', -3: 'P', -2: 'O', -1: 'N',\n      0: 'Z', 1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E',\n      6: 'F', 7: 'G', 8: 'H', 9: 'I', 10: 'K', 11: 'L', 12: 'M'\n    };\n    \n    String code = nauticalCodes[roundedOffset] ?? 'Z';\n    return '$code (UTC${roundedOffset >= 0 ? '+' : ''}$roundedOffset)';\n  }\n}\n\n// Usage examples and test function\nvoid main() {\n  // Test coordinates\n  List<Map<String, dynamic>> testLocations = [\n    {'name': 'New York', 'lat': 40.7128, 'lon': -74.0060},\n    {'name': 'London', 'lat': 51.5074, 'lon': -0.1278},\n    {'name': 'Tokyo', 'lat': 35.6762, 'lon': 139.6503},\n    {'name': 'Sydney', 'lat': -33.8688, 'lon': 151.2093},\n    {'name': 'Los Angeles', 'lat': 34.0522, 'lon': -118.2437},\n    {'name': 'Mumbai', 'lat': 19.0760, 'lon': 72.8777},\n  ];\n\n  print('=== Offline Timezone Calculator Results ===\\n');\n\n  for (var location in testLocations) {\n    String name = location['name'];\n    double lat = location['lat'];\n    double lon = location['lon'];\n\n    print('Location: $name (${lat.toStringAsFixed(4)}, ${lon.toStringAsFixed(4)})');\n    \n    // Method 1: Simple longitude-based\n    double simpleOffset = OfflineTimezoneCalculator.getTimezoneByLongitude(lon);\n    print('  Simple Longitude: UTC${simpleOffset >= 0 ? '+' : ''}${simpleOffset.toStringAsFixed(1)}');\n    \n    // Method 2: Country-based\n    String countryTz = OfflineTimezoneCalculator.getTimezoneByCountryBounds(lat, lon);\n    print('  Country-based: $countryTz');\n    \n    // Method 3: Detailed with DST\n    Map<String, dynamic> detailed = OfflineTimezoneCalculator.getDetailedTimezone(lat, lon);\n    print('  Detailed: ${detailed['timezone']} (${detailed['offsetString']}) DST: ${detailed['isDST']}');\n    \n    // Method 4: Grid-based\n    String gridTz = OfflineTimezoneCalculator.getTimezoneByGrid(lat, lon);\n    print('  Grid-based: $gridTz');\n    \n    // Method 5: Solar timezone\n    double solarTz = OfflineTimezoneCalculator.getSolarTimezone(lon);\n    print('  Solar: UTC${solarTz >= 0 ? '+' : ''}${solarTz.toStringAsFixed(2)}');\n    \n    // Method 6: Nautical\n    String nautical = OfflineTimezoneCalculator.getNauticalTimezone(lat, lon);\n    print('  Nautical: $nautical');\n    \n    print('');\n  }\n}"
        }
    ]
}